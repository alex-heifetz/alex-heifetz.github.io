Объяснить, почему важно держать дерево «красивым», и что эта красота нам дает?  
## 1. Что такое «красивое» дерево в Git?

Это история коммитов, которая:  
✅ **Линейная** – минимум merge-коммитов, нет «ветвящегося спагетти».  
✅ **Атомарная** – каждый коммит делает одну логическую вещь (фича, багфикс, рефакторинг).  
✅ **Читаемая** – сообщения коммитов объясняют **зачем**, а не **что** (не `fix bug`, а `fix: handle null pointer in user auth`).

**Пример «некрасивого» дерева:**

```
*   Merge branch 'feature-123' into dev  
|\  
| * fix: typo  
| * WIP: add new button  
* |   Merge branch 'hotfix-1'  
|\ \  
| * | chore: update config  
| |/  
* | feat: add login form  
|/  
* Initial commit  
```

**Пример «красивого» дерева:**

```
* feat(auth): add Google OAuth2  
* fix(api): handle null response in /user  
* refactor(styles): migrate to CSS modules  
* chore: update dependencies  
* Initial commit  
```

Как этого добиваться:
- время от времени актуализировать ветки с помощью rebase;
- при ребейсе сквошить коммиты. 
Если периодически ребейсить коммиты то в дальнейшем будет возникать меньше проблем при их мерже.

  ----
  
## 2. Для чего использовать conventional commit? Что это дает и какие проблемы решает?  

**Conventional Commits** — это соглашение о формате сообщений коммитов в Git, которое стандартизирует их структуру. Оно помогает сделать историю изменений более понятной, автоматизировать процессы (например, генерацию changelog или версионирование) и улучшить взаимодействие в команде.
### **Основные преимущества Conventional Commits**  
1. **Чёткая структура коммитов**  
   - Сообщения имеют единый формат:  
     ```
     <type>[scope]: <description>
     [body]
     [footer]
     ```
     Пример:  
     ```
     feat(auth): add Google OAuth login
     fix(api): handle null response in /users endpoint
     ```

2. **Автоматизация версионирования (SemVer)**  
   - `feat` → Минорная версия (`v1.2.0` → `v1.3.0`)  
   - `fix` → Патч-версия (`v1.2.0` → `v1.2.1`)  
   - Breaking changes (`!` или `BREAKING CHANGE:`) → Мажорная версия (`v1.2.0` → `v2.0.0`)  
   - Инструменты вроде `standard-version` или `semantic-release` используют это для авто-генерации версий.

3. **Автоматическая генерация CHANGELOG.md**  
   - Можно автоматически формировать список изменений по типам (`feat`, `fix`, `chore` и т. д.).

4. **Улучшенный code review**  
   - По коммиту сразу понятно, что он содержит (новая фича, багфикс, рефакторинг).  
   - Легче отслеживать breaking changes.
### **Какие проблемы решает?**  
- **Беспорядок в истории Git** → Стандартизирует коммиты.  
- **Ручное управление версиями** → Автоматизирует SemVer.  
- **Хаотичные сообщения коммитов** → Делает их читаемыми и полезными.  
- **Сложность отслеживания изменений** → Позволяет фильтровать коммиты по типам.  

### **Примеры типов коммитов**  
| Тип       | Описание                                  | Пример                          |
|-----------|------------------------------------------|---------------------------------|
| `feat`    | Новая функциональность                   | `feat(login): add SSO support`  |
| `fix`     | Исправление бага                         | `fix(api): prevent race condition` |
| `docs`    | Изменения в документации                 | `docs(readme): update examples`  |
| `style`   | Форматирование (пробелы, точки с запятой)| `style: fix lint errors`         |
| `refactor`| Рефакторинг без изменения логики         | `refactor(db): simplify queries`|
| `chore`   | Вспомогательные изменения (сборка, зависимости) | `chore(deps): update lodash` |
| `test`    | Тесты                                    | `test(auth): add OAuth2 mocks`  |


---
  
## Почему rebase, а не merge?  

Выбор между `rebase` и `merge` зависит от контекста и предпочтений команды. Оба метода служат для интеграции изменений из одной ветки в другую, но делают это по-разному.

### **Когда использовать `rebase`?**

✅ **Лучше для локальной истории** – перебазирование переписывает историю коммитов, делая её линейной и чистой.  
✅ **Перед пул-реквестом** – чтобы избежать лишних коммитов слияния (`Merge branch 'feature' into main`).  
✅ **Работа в одиночку** – если вы единственный разработчик в ветке, `rebase` безопасен.

⚠ **Осторожно!** Не используйте `rebase` на публичных ветках (например, `main` или `develop`), если другие разработчики уже начали работать поверх них – это вызовет конфликты.

### **Когда использовать `merge`?**

✅ **Сохраняет историю** – создаёт отдельный коммит слияния, что полезно для отслеживания, когда и какие ветки были объединены.  
✅ **Безопасен для общих веток** – не переписывает историю, поэтому не ломает работу коллег.  
✅ **Проще в использовании** – меньше шансов ошибиться, особенно для новичков.

---

Как делать revert? 

А если с релизом пошло что-то не так, что делать?  
Я думаю рано или поздно придем к тому, что каждый стек будет сам проводить релизы
Про revert, cherry peak, я могу рассказать. С релизом часто hard reset и force push больше помогает чем revert


Расскать про одинаковые изменения в разных ветках можно вынести в отдельный коммит и обе ветки ребейснуть на него. 